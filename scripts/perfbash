#!/bin/bash
set -euo pipefail
DIR="$(dirname "$(readlink -f "$0")")"/..
perfargs=()
. "$DIR"/bin/L_lib.sh L_argparse \
  description="This is a command that executes a Bash script and under perf stat with minimal interference from the system.
Bash script is executed in a chroot under bwrap to not load anything." \
  -- -r --repeat help="Repeat the command that many times" \
  -- -v --verbose action=count default=0 \
  -- -b --binary help="Add binary" action=append dest=binaries help="Additoinal binaries to add to image" \
  -- --table eval='perfargs+=(--table)' help="pass --table to perf" \
  -- -C --compare action=append default= help="
For every argument that is a bash script collect measurements and present them in a table.
Pass script arguments as an option to --compare option. Example: --compare arg1 --compare arg2 -- 'test -e \$1' 'ls -A \$1'
" \
  -- -p --perfargs action=append help="additoinal perf arguments" \
  -- -d --diff flag=1 help="Show difference scripts execution instructions and times" \
  -- -P --previous flag=1 help="Show difference to previous execution of the script" \
  -- --prefix help="Add this at th begining of the script" \
  -- command nargs="+" help="Shell script to execute. Passed to bash -c" \
  ---- "$@"
#
extract_from_run() {
  local args i
  args=(${repeat+-r"$repeat"} "${binaries[@]/#/-b}")
  for i in $(seq $verbose); do
    args+=(-v)
  done
  #
  ret=0
  out=$(L_run "$0" -p -o/dev/stdout "${args[@]}" "$@") || ret=$?
  extract_stats "$out"
}
extract_stats() {
  instructions=$(awk '/cpu_core\/instructions\/u/{print $1}' <<<"$1")
  seconds_time_elapsed=$(awk '/seconds time elapsed/{print $1}' <<<"$1")
  seconds_time_elapsed_dev=$(awk '/seconds time elapsed/{print $3}' <<<"$1")
  seconds_time_elapsed_percent=$(awk '/seconds time elapsed/{print $9}' <<<"$1")
  user_time=$(awk '/user_time/{print $1}' <<<"$1")
  system_time=$(awk '/system_time/{print $1}' <<<"$1")
}
diff_prepare() {
  instructions_empty=$instructions
  seconds_time_elapsed_empty=$seconds_time_elapsed
  user_time_empty=$user_time
  system_time_empty=$system_time
}
diff_show() {
  # echo "$out" | sed '/^$/d' | grep -E 'Performance counter stats|user_time|system_time|cpu_core/instructions|seconds time'
  echo "$out" | sed '/^$/d'
  printf "%+18d""    instructions diff to previous ( %+5.2f%% )\n" \
    "$((instructions - instructions_empty))" \
    "$(bc -l <<<"100 * ($instructions - $instructions_empty) / $instructions_empty" )"
  printf "%+18.7f    elapsed seconds diff to previous ( %+5.2f%% )\n" \
    "$(bc -l <<<"$seconds_time_elapsed - $seconds_time_elapsed_empty" )" \
    "$(bc -l <<<"100 * ($seconds_time_elapsed - $seconds_time_elapsed_empty) / $seconds_time_elapsed_empty" )"
  # printf "%+18d""    user_time diff to previous\n" "$((user_time - user_time_empty))"
  # printf "%+18d""    system_time diff to previous\n" "$((system_time - system_time_empty))"
}
#
if ((previous)); then
  prevf=/tmp/perfbash.txt
  if [[ ! -e "$prevf" ]]; then
    extract_from_run ''
    echo "$out" > "$prevf"
  fi
  out=$(< "$prevf")
  extract_stats "$out"
  for c in "${command[@]}"; do
    diff_prepare
    extract_from_run "$c"
    diff_show
    echo "$out" >"$prevf"
  done
  exit "$ret"
fi
#
if ((diff)); then
  extract_from_run ''
  # echo "$out"
  for c in "${command[@]}"; do
    diff_prepare
    extract_from_run "$c"
    diff_show
  done
  exit "$ret"
fi
#
if ((${#compare[@]})); then
  for arg in "${compare[@]}"; do
    partresult=""
    for script in "${command[@]}"; do
      extract_from_run "$prefix$script" bash "$arg"
      script_str=${script//[ $'\t\n']/ }
      max_len=70
      script_str=${script_str:${#script_str} > max_len ? ${#script_str} - max_len : 0}
      partresult+="\`$script_str\`$L_RS$arg$L_RS$ret$L_RS$instructions$L_RS$seconds_time_elapsed Â± $seconds_time_elapsed_dev ($seconds_time_elapsed_percent)$L_RS"$'\n'
    done
    result+=$(sort -t "$L_RS" -k 4 -n <<<"$partresult")
  done
  result="---$L_RS---$L_RS---$L_RS"$'\n'"$result"
  output=$(column -s "$L_RS" -o ' | ' -t -N 'command,arg,exit,instructions,seconds time elapsed' <<<"$result" | sed 's/^/| /; s/ $//')
cat <<EOF
\`\`\`
$(L_quote_setx "$@")
\`\`\`

$output
EOF
  exit
fi
#
binaries=(bash perf "${binaries[@]}")
paths=(
  /lib64/ld-linux-x86-64.so.2
  # $(pacman -Ql perf | awk '{print $2}' | grep -v '/$')
)
#
bwrapargs=()
for i in "${binaries[@]}"; do
  i=$(which -- "$i")
  L_assert '' test -e "$i"
  bwrapargs+=(--bind "$i" "$i")
  for i in $(ldd -- "$i" | grep '=>' | awk '{print $3}'); do
    L_assert '' test -e "$i"
    bwrapargs+=(--bind "$i" "$i")
  done
done
for i in "${paths[@]}"; do
  bwrapargs+=(--bind "$i" "$i")
done
for i in /proc /dev /sys; do
  bwrapargs+=(--dev-bind "$i" "$i")
done
#
if ((verbose)); then
  set -x
fi
taskset 1 \
  bwrap \
  --clearenv \
  --setenv PATH /bin:/usr/bin:/sbin:/usr/sbin \
  --bind "$DIR" "$DIR" \
  "${bwrapargs[@]}" \
  -- \
  "$(which perf)" stat \
  -e cycles,instructions,user_time,system_time \
  ${repeat+-r"$repeat"} \
  "${perfargs[@]}" \
  -- \
  "$(which bash)" -c "${command[@]}" <&-

